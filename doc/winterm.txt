*winterm.txt*        Multi-terminal window manager for Neovim

Author:     gh-liu
License:    MIT
Repository: https://github.com/gh-liu/nvim-winterm

==============================================================================
CONTENTS                                                    *winterm-contents*

1. Introduction                                             |winterm-intro|
2. Installation                                             |winterm-install|
3. Configuration                                            |winterm-config|
4. Commands                                                 |winterm-commands|
5. Lua API                                                  |winterm-lua-api|
6. Highlight                                                |winterm-highlight|
7. Advanced Usage                                           |winterm-advanced|

==============================================================================
INTRODUCTION                                               *winterm-intro*

nvim-winterm is a multi-terminal window manager for Neovim. It allows you to
manage multiple terminal instances in a single window with a winbar for
quick navigation.

Features:
- Multiple terminal instances in one window
- Winbar for terminal navigation
- Terminal-specific working directories
- Shell command completion
- Relative and absolute terminal indexing

==============================================================================
INSTALLATION                                               *winterm-install*

With lazy.nvim:
>
    {
        "gh-liu/nvim-winterm",
        opts = {
            win = {
                height = 0.3,
            },
        },
    },
<

==============================================================================
CONFIGURATION                                              *winterm-config*

Setup with default options:
>
    require("winterm").setup({
        win = {
            height = 0.3,    -- 30% of screen height
        },
    })
<

Options:

    win.height (number)                          *winterm-config-win-height*
        Window height as a ratio of screen lines. Default: 0.3

==============================================================================
COMMANDS                                                   *winterm-commands*

:Winterm                                                      *:Winterm*
    Toggle the terminal window. Opens a shell the first time.

:Winterm {cmd}                                                *:Winterm-cmd*
    Create a terminal running {cmd}.

:Winterm -dir={path} {cmd}                                    *:Winterm-dir*
    Create a terminal in {path} running {cmd}.
    Supports: -dir=path, -dir="path with spaces", -dir='path'

:Winterm [N]                                                  *:Winterm-focus*
    Focus terminal by index N. Uses count if given (e.g., :3Winterm).

:Winterm! [N]                                                 *:Winterm-kill*
    Kill terminal by index N. Force close with !.
    Uses count if given (e.g., :3Winterm!).

Relative navigation:
    :Winterm +N     Focus Nth terminal after current
    :Winterm -N     Focus Nth terminal before current
    :Winterm! +N    Kill Nth terminal after current
    :Winterm! -N    Kill Nth terminal before current

==============================================================================
LUA API                                                   *winterm-lua-api*

run({cmd}, {opts}) -> term
    Run a command and return a stable term object (identified by bufnr).
    opts:
        cwd   (string)   Working directory
        focus (boolean)  Focus the terminal after creation

list() -> term[]
    Return all term objects.

Example:
>
    local winterm = require("winterm")

    local term = winterm.run("npm run dev", { focus = false })
    if term then
        term:focus()
    end

    vim.ui.select(winterm.list(), {
        prompt = "Winterm terminals",
        format_item = function(item)
            return string.format("%s  (%s)", item.cmd, item.cwd or "")
        end,
    }, function(choice)
        if choice then
            choice:focus()
        end
    end)
<

==============================================================================
HIGHLIGHT                                                   *winterm-highlight*

WintermWinbar                                               *WintermWinbar*
    Winbar highlighting for inactive terminals. Linked to |hl-TabLine| by default.

WintermWinbarSel                                            *WintermWinbarSel*
    Winbar highlighting for the active terminal. Linked to |hl-TabLineSel| by default.

To customize:
>
    vim.api.nvim_set_hl(0, "WintermWinbar", { fg = "#ffffff", bg = "#333333" })
    vim.api.nvim_set_hl(0, "WintermWinbarSel", { fg = "#ffffff", bg = "#666666" })
<

==============================================================================
ADVANCED USAGE                                              *winterm-advanced*

Handling closed terminals with user-defined keymaps~

When a terminal process exits, the buffer becomes "closed" but remains in the
buffer list. By default, pressing any key in insert mode on a closed terminal
buffer will trigger automatic cleanup.

For more explicit control, you can customize this behavior by setting a keymap
when the terminal closes. This approach:
- Only affects the closed terminal buffer (buffer-local keymap)
- Avoids global key listeners
- Gives users a clear, deterministic experience

Example configuration:
>
    local cleanup_group = vim.api.nvim_create_augroup("WintermTermClose", {})
    
    vim.api.nvim_create_autocmd("TermClose", {
        group = cleanup_group,
        callback = function(event)
            local ok, is_winterm = pcall(vim.api.nvim_buf_get_var, event.buf, "winterm")
            if not (ok and is_winterm) then
                return
            end
            
            -- Exit insert mode
            vim.api.nvim_buf_call(event.buf, function()
                vim.cmd.stopinsert()
            end)
            
            -- Set keymap to clean up on Enter
            vim.keymap.set("n", "<CR>", function()
                vim.api.nvim_buf_delete(event.buf, { force = true })
            end, { buffer = event.buf, noremap = true })
        end,
    })
<

This approach has several advantages:
- Works with existing BufWipeout cleanup logic
- No performance overhead from global listeners
- Buffer-local scope prevents unintended side effects
- User has explicit control over when cleanup happens

==============================================================================
vim:tw=78:ts=8:noet:ft=help:norl:
